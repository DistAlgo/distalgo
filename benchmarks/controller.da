"""
This is a small library for instrumenting DistAlgo programs for
benchmarking. It assumes that each process is created in main()
and lives for the duration of the benchmark.

A single controller process is created to coordinate when the
other processes ("controllees") begin and end, and to collect
their results. The controller is initialized with the number of
controllees to expect, and does the following steps:

    1. Wait for nprocs many ('CTL_Ready',) messages.
    2. Broadcast ('CTL_Start',) to everyone.
    3. Wait for nprocs many ('CTL_Done', cputime) messages.
    4. Send ('CTL_Terminate',) to everyone.

It then outputs two metrics:

    1) The wall-clock time, as measured by the controller, between
       the beginning of step (2) and the end of step (3);
    
    2) The total sum of the process times, as measured by the
       controllees between receiving CTL_Start and sending CTL_Done. 

Note in particular that these two measurements exclude the time needed
to create and destroy the DistAlgo processes.

This data is printed on stdout in the form of a line "OUTPUT: <data>"
where data is a simple JSON-encoded object.

To adapt a DistAlgo program to use this, make the following changes.

    At the top of the file, add the line
    
        controller = import_da('controller')
    
    For each process class,
    
      - add controller.Controllee as a base class
      - add a process field and setup() parameter "ctl"
      - in the body of setup(), add the line "super().setup(ctl)"
      - above the definition of run(), add the decorator "@controller.run"
    
    In main(), first create a Controller process using the code
    
        ctl = new(controller.Controller, num= 1)
        setup(ctl, (nprocs,))
        start(ctl)
    
    where nprocs is the number of controllee processes. Then in each
    controllee's new() or setup() method, add ctl to the list of
    passed-in arguments.
"""

import time
import json

class Controller(process):
    
    def setup(nprocs):
        # Processes we are controlling, and number
        # of processes that have sent ready/done messages.
        self.ps = set()
        self.readys = 0
        self.dones = 0
        
        # Total of all processes' cputime.
        self.cputime = 0
        
        self.ctl_verbose = True
    
    def verboutput(s):
        if ctl_verbose:
            output(s)
    
    def receive(msg=('CTL_Ready',), from_=source):
        # Count readys.
        ps.add(source)
        readys += 1
        verboutput('Got Ready ({}/{})'.format(readys, nprocs))
    
    def receive(msg=('CTL_Done', time), from_=source):
        # Count dones.
        dones += 1
        cputime += time
        verboutput('Got Done ({}/{})'.format(dones, nprocs))
    
    def run():
        # Start 'em up.
        await(readys == nprocs)
        verboutput("Controller starting everyone")
        
        t1 = time.perf_counter()
        bcast(('CTL_Start',), to=ps)
        
        # Shut 'em down.
        await(dones == nprocs)
        t2 = time.perf_counter()
        verboutput("Everyone done")
        
        jsondata = {'Wall time': t2 - t1,
                    'Total process time': cputime}
        jsonoutput = json.dumps(jsondata)
        print("OUTPUT: " + jsonoutput)
        
        bcast(('CTL_Terminate',), to=ps)
        time.sleep(1)

class Controllee(process):
    
    def setup(ctl):
        self.ctl_starttime = 0
        self.ctl_endtime = 0
        self.ctl_verbose = True
    
    def verboutput(s):
        if ctl_verbose:
            output(s)
    
    def ctl_begin():
        # Tell controller we're initialized, then wait for the signal.
        send(('CTL_Ready',), to=ctl)
        await(received(('CTL_Start',)))
        
        ctl_starttime = time.process_time()
    
    def ctl_end():
        ctl_endtime = time.process_time()
        
        # Tell controller we're done, wait for signal.
        send(('CTL_Done', ctl_endtime - ctl_starttime), to=ctl)
        await(received(('CTL_Terminate',)))
        verboutput("Terminating...")
    
    def run():
        # Stub to squelch warning.
        pass

def run(func):
    def ctl_run(self):
        self.ctl_begin()
        func(self)
        self.ctl_end()
    return ctl_run
