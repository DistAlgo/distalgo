# Copyright (c) 2014 Jon Brandvein, Bo Lin, Yanhong Annie Liu
# Copyright (c) 2014 Stony Brook University
# Copyright (c) 2014 The Research Foundation of SUNY
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

"""
This is a small library for instrumenting DistAlgo programs for
benchmarking. It assumes that each process is created in main()
and lives for the duration of the benchmark.

A single controller process is created to coordinate when the
other processes ("controllees") begin and end, and to collect
their results. The controller is initialized with the number of
controllees to expect, and does the following steps:

    1. Wait for nprocs many ('CTL_Ready',) messages.
    2. Broadcast ('CTL_Start',) to everyone.
    3. Wait for nprocs many ('CTL_Done', cputime) messages.
    4. Send ('CTL_Terminate',) to everyone.

It then outputs two metrics:

    1) The wall-clock time, as measured by the controller, between
       the beginning of step (2) and the end of step (3);
    
    2) The total sum of the process times, as measured by the
       controllees between receiving CTL_Start and sending CTL_Done. 

Note in particular that these two measurements exclude the time needed
to create and destroy the DistAlgo processes.

This data is printed on stdout in the form of a line "OUTPUT: <data>"
where data is a simple JSON-encoded object.

To adapt a DistAlgo program to use this, make the following changes.

    At the top of the file, add the line
    
        controller = import_da('controller')
    
    For each process class,
    
      - add controller.Controllee as a base class
      - add a process field and setup() parameter "ctl"
      - in the body of setup(), add the line "super().setup(ctl)"
      - above the definition of run(), add the decorator "@controller.run"
    
    In main(), first create a Controller process using the code
    
        ctl = new(controller.Controller, num= 1)
        setup(ctl, (nprocs,))
        start(ctl)
    
    where nprocs is the number of controllee processes. Then in each
    controllee's new() or setup() method, add ctl to the list of
    passed-in arguments.
"""

import time
import json

class Controller(process):
    
    def setup(nprocs):
        # Processes we are controlling, and number
        # of processes that have sent ready/done messages.
        self.ps = set()
        self.readys = 0
        self.dones = 0
        
        # Total of all processes' cputime.
        self.cputime = 0
        
        self.ctl_verbose = True
    
    def verboutput(s):
        if ctl_verbose:
            output(s)
    
    def receive(msg=('CTL_Ready',), from_=source):
        # Count readys.
        ps.add(source)
        readys += 1
        verboutput('Got Ready from {} ({}/{})'.format(source, readys, nprocs))
    
    def receive(msg=('CTL_Done', time), from_=source):
        # Count dones.
        dones += 1
        cputime += time
        verboutput('Got Done from {} ({}/{})'.format(source, dones, nprocs))
    
    def run():
        # Start 'em up.
        await(readys == nprocs)
        verboutput("Controller starting everyone")
        
        t1 = time.perf_counter()
        bcast(('CTL_Start',), to=ps)
        
        # Shut 'em down.
        await(dones == nprocs)
        t2 = time.perf_counter()
        verboutput("Everyone done")
        
        jsondata = {'Wall time': t2 - t1,
                    'Total process time': cputime}
        jsonoutput = json.dumps(jsondata)
        print("OUTPUT: " + jsonoutput)
        
        bcast(('CTL_Terminate',), to=ps)
        time.sleep(1)

class Controllee(process):
    
    def setup(ctl):
        self.ctl_starttime = 0
        self.ctl_endtime = 0
        self.ctl_verbose = True
    
    def verboutput(s):
        if ctl_verbose:
            output(s)
    
    def ctl_begin():
        # Tell controller we're initialized, then wait for the signal.
        send(('CTL_Ready',), to=ctl)
        await(received(('CTL_Start',)))
        
        ctl_starttime = time.process_time()
    
    def ctl_end():
        ctl_endtime = time.process_time()
        
        # Tell controller we're done, wait for signal.
        send(('CTL_Done', ctl_endtime - ctl_starttime), to=ctl)
        await(received(('CTL_Terminate',)))
        verboutput("Terminating...")
    
    def run():
        # Stub to squelch warning.
        pass

def run(func):
    def ctl_run(self):
        self.ctl_begin()
        func(self)
        self.ctl_end()
    return ctl_run
