# Copyright (c) 2015 Jon Brandvein, Bo Lin, Yanhong Annie Liu
# Copyright (c) 2015 Stony Brook University
# Copyright (c) 2015 The Research Foundation of SUNY
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

"""
This is a small library for instrumenting DistAlgo programs for
benchmarking. It assumes that each process is created in main()
and lives for the duration of the benchmark.

A single controller process is created to coordinate when the
other processes ("controllees") begin and end, and to collect
their results. The controller is initialized with the number of
controllees to expect, and does the following steps:

    1. Wait for nprocs many ('CTL_Ready',) messages.
    2. Broadcast ('CTL_Start',) to everyone.
    3. Wait for nprocs many ('CTL_Done', rudata) messages.
    4. Send ('CTL_Terminate',) to everyone.

It then outputs platform-dependent metrics of performance.
Wall-clock time is measured by the controller between the beginning
of step (2) and the end of step (3). Process time is measured by
each controllee between receiving CTL_Start and sending CTL_Done;
these are summed together and reported by the controller. Note in
particular that these time measurements exclude the time needed
to create and destroy the DistAlgo processes.

This data is printed on stdout in the form of a line "###OUTPUT: <data>"
where data is a simple JSON-encoded object.

To adapt a DistAlgo program to use this, make the following changes.

    At the top of the file, add the line
    
        controller = import_da('controller')
    
    For each process class,
    
      - add controller.Controllee as a base class
      - add a process field and setup() parameter "ctl"
      - in the body of setup(), add the line "super().setup(ctl)"
      - above the definition of run(), add the decorator "@controller.run"
    
    In main(), first create a Controller process using the code
    
        ctl = new(controller.Controller, num= 1)
        setup(ctl, (nprocs,))
        start(ctl)
    
    where nprocs is the number of controllee processes. Then in each
    controllee's new() or setup() method, add ctl to the list of
    passed-in arguments.
"""


import sys
import time
import json


# Resource usage data tracking. Reports several measurements
# of time between start and end, and memory usage at end.

class WinResourceUsageData:
    
    """Tracks process time only."""
    
    def start(self):
        self.start_cputime = time.process_time()
    
    def end(self):
        self.end_cputime = time.process_time()
        
        self.results = {
            'Total_process_time': self.end_cputime - self.start_cputime,
        }
    
    @classmethod
    def aggregate(cls, rudata_points):
        return {'Total_process_time': sum(p.results['Total_process_time']
                                          for p in rudata_points)}

class PosixResourceUsageData:
    
    """Tracks utime, stime, and maxrss."""
    
    def start(self):
        self.start_data = resource.getrusage(resource.RUSAGE_SELF)
    
    def end(self):
        self.end_data = resource.getrusage(resource.RUSAGE_SELF)
        
        def diff(attr):
            return (getattr(self.end_data, attr) -
                    getattr(self.start_data, attr))
        
        self.results = {
            'Total_user_time': diff('ru_utime'),
            'Total_system_time': diff('ru_stime'),
            'Total_process_time': diff('ru_utime') + diff('ru_stime'),
            'Total_memory': self.end_data.ru_maxrss,
        }
    
    @classmethod
    def aggregate(cls, rudata_points):
        def sumof(attr):
            return sum(p.results[attr] for p in rudata_points)
        return {k: sumof(k) for k in [
                'Total_user_time', 'Total_system_time',
                'Total_process_time', 'Total_memory']}

if sys.platform == "win32":
    ResourceUsageData = WinResourceUsageData
else:
    import resource
    ResourceUsageData = PosixResourceUsageData


ExcludedProcs = set()


class Controller(process):
    
    def setup(nprocs):
        # Processes we are controlling, and number
        # of processes that have sent ready/done messages.
        self.ps = set()
        self.readys = 0
        self.dones = 0
        
        self.collected = 0
        self.rudata_points = []
        
        self.ctl_verbose = True
    
    def verboutput(s):
        if ctl_verbose:
            output(s)
    
    def receive(msg=('CTL_Ready',), from_=source):
        # Count readys.
        ps.add(source)
        readys += 1
        verboutput('Got Ready from {} ({}/{})'.format(source, readys, nprocs))
    
    def receive(msg=('CTL_Done', rudata), from_=source):
        # Count dones.
        dones += 1
        if source._proctype not in ExcludedProcs:
            rudata_points.append(rudata)
            collected += 1
        verboutput('Got Done from {} ({}/{})'.format(source, dones, nprocs))
    
    def run():
        # Start 'em up.
        await(readys == nprocs)
        verboutput("Controller starting everyone")
        
        t1 = time.perf_counter()
        bcast(('CTL_Start',), to=ps)
        
        # Shut 'em down.
        await(dones == nprocs)
        t2 = time.perf_counter()
        verboutput("Everyone done")
        bcast(('CTL_Terminate',), to=ps)
        
        jsondata = ResourceUsageData.aggregate(rudata_points)
        jsondata['Wallclock_time'] = t2 - t1
        jsondata['Total_processes'] = collected
        jsonoutput = json.dumps(jsondata)
        print("###OUTPUT: " + jsonoutput)
        
        time.sleep(1)

class Controllee(process):
    
    def setup(ctl):
        self.ctl_starttime = 0
        self.ctl_endtime = 0
        self.rudata = ResourceUsageData()
        self.ctl_verbose = True
    
    def verboutput(s):
        if ctl_verbose:
            output(s)
    
    def ctl_begin():
        # Tell controller we're initialized, then wait for the signal.
        send(('CTL_Ready',), to=ctl)
        await(received(('CTL_Start',)))
        self.rudata.start()
    
    def ctl_end():
        self.rudata.end()
        # Tell controller we're done, wait for signal.
        send(('CTL_Done', self.rudata), to=ctl)
        await(received(('CTL_Terminate',)))
        verboutput("Terminating...")
    
    def run():
        # Stub to squelch warning.
        pass

def run(func):
    def ctl_run(self):
        self.ctl_begin()
        func(self)
        self.ctl_end()
    return ctl_run

def excluded(proc):
    ExcludedProcs.add(proc)
    return proc
